(cl:in-package #:coalton-native-tests)

(coalton-toplevel
  (declare >-ord (Integer -> Integer -> Ord))
  (define (>-ord a b)
    (cond
      ((== a b)
       EQ)
      ((< a b)
       GT)
      ((> a b)
       LT))))

(define-test test-vector-constructor-equivalencies ()
  (let vec = (vector:with-capacity 10))
  (iter:for-each! (fn (x)
                    (cln:push! x vec)
                    Unit)
                  (iter:up-to 10))
  (is (== (vector:make 0 1 2 3 4 5 6 7 8 9)
          vec))
  (is (== (iter:collect! (iter:up-to 10))
          vec)))

(define-test test-vector-initial-element ()
  (== (vector:make "x" "x" "x") (cln:new-repeat 3 "x")))

(define-test test-vector-basic-operations ()
  (let vec0 = (vector:make))
  (let vec1 = (vector:make 10 11 12 13 14))
  (iter:for-each! (fn (x)
                    (cln:push! x vec0)
                    Unit)
                  (iter:up-to 5))
  (is (== (vector:make 0 1 2 3 4 10 11 12 13 14)
          (vector:append vec0 vec1)))
  (is (== (vector:make 4 3 2 1 0)
          (cln:reverse vec0)))
  (is (== (vector:make 0 1 2 3 4)
          vec0))                        ;ensure vec0 is intact
  (is (== (vector:make 4 3 2 1 0)
          (cln:reverse! vec0)))
  (vector:clear! vec0)
  (is (== (vector:make) vec0))
  (is (== True (cln:empty? vec0)))
  (is (== (Some 2) (cln:index-elt 12 vec1)))
  (is (== None (cln:index-elt 0 vec1)))
  (is (== None (cln:head vec0)))
  (is (== (Some 10) (cln:head vec1)))
  (is (== None (vector:index 1 vec0)))
  (is (== (Some 11) (vector:index 1 vec1)))
  (is (== None (cln:last vec0)))
  (is (== (Some 14) (cln:last vec1)))
  (is (== (Some 14) (cln:pop! vec1)))
  (is (== (Some 13) (cln:last vec1)))
  (cln:push! 9 vec1)
  (is (== (Some 9) (cln:last vec1)))
  (let vec2 = (fold vector:append
                    (vector:singleton 99)
                    (make-list vec1 (vector:make 2 7))))
  (is (== (vector:make 99 10 11 12 13 9 2 7) vec2))
  (cln:sort! vec2)
  (is (== (vector:make 2 7 9 10 11 12 13 99) vec2))
  (cln:sort-with! >-ord vec2)
  (is (== (vector:make 99 13 12 11 10 9 7 2) vec2))
  (vector:set! 3 88 vec2)
  (is (== (vector:make 99 13 12 88 10 9 7 2) vec2))
  (vector:set-capacity! 5 vec2)
  (is (== (vector:make 99 13 12 88 10) vec2))
  (is (== (Some 12) (vector:swap-remove! 2 vec2)))
  (is (== (vector:make 99 13 10 88) vec2))
  (is (== None (vector:swap-remove! 10 vec2)))
  (is (== (vector:make 99 13 10 88) vec2))
  (vector:extend! vec2 (iter:into-iter (make-list 5 6 7 8)))
  (is (== (vector:make 99 13 10 88 5 6 7 8) vec2))

  (let vec3 = (vector:singleton "a"))
  (is (== (Some "a") (vector:swap-remove! 0 vec3)))
  (is (== True (cln:empty? vec3)))
  (is (== None (vector:swap-remove! 0 vec3)))

  (is (== False (vector:singleton? vec2)))
  (is (== False (vector:singleton? (vector:make))))
  (is (== True (vector:singleton? (vector:make 1))))
  )
